<?php
/**
 * This file is part of the library rewrite based on sc2calc.org
 * (c) Matthias Lantsch.
 *
 * @license http://www.wtfpl.net/ Do what the fuck you want Public License
 * @author  Matthias Lantsch <matthias.lantsch@bluewin.ch>
 */

namespace holonet\sc2calc\cli\commands;

use RuntimeException;
use holonet\cli\Command;
use holonet\sc2calc\Utils;
use holonet\sc2calc\Sc2Calc;
use holonet\sc2calc\Sc2Build;
use holonet\sc2calc\enum\Race;
use holonet\cli\argparse\Argument;
use Codedungeon\PHPCliColors\Color;
use Symfony\Component\Stopwatch\Stopwatch;
use holonet\cli\error\InvalidUsageException;
use holonet\sc2calc\error\InvalidBuildException;
use holonet\sc2calc\error\InvalidFormatException;

class CalculateCommand extends Command {
	/**
	 * {@inheritdoc}
	 */
	public function configure(): void {
		$this->argumentDefinition->addOption('i|infile', 'in_file', 'file path with the input build order')->optional(true);
		$this->argumentDefinition->addOption('b|instring', 'in_string', 'build order string')->optional(true);
		$this->argumentDefinition->addOption('f|informat', 'in_format', 'what format the input build is in (defaults to "string")')->default('string');
		$this->argumentDefinition->addFlag('s|silent', 'silent', 'Don\'t print general build calculation results to stdout')->default(false);
	}

	/**
	 * {@inheritdoc}
	 */
	public function describe(): string {
		return 'Run the calculator over a build and print / write the output as specified';
	}

	/**
	 * {@inheritdoc}
	 */
	public function execute(): void {
		$stopwatch = new Stopwatch();
		$stopwatch->start('processing');

		if ($this->input->getArg('debug')) {
			Sc2Calc::$DEBUG_PRINT = true;
		}

		$sc2calc = new Sc2Calc();

		$inputOrder = $this->getBuildOrderFromInput();

		try {
			$build = $sc2calc->fromFormat($inputOrder, $this->input->getArg('in_format'));
			if (!$this->input->getArg('silent')) {
				$this->printBuild($build);
			}
		} catch (InvalidFormatException $e) {
			throw new InvalidUsageException($e->getMessage(), (int)$e->getCode(), $e);
		} catch (InvalidBuildException $e) {
			$this->output->writeErrLn("\nInvalid build:");
			$this->output->writeErrLn($e->getMessage());
			$this->output->writeErr('    '.str_replace('.', ".\n   ", $e->description ?? ''), Color::RED);
		}

		$stopEvent = $stopwatch->stop('processing');

		$this->output->writeOutLn(sprintf(
			'%sProcessed build using: %.2F MiB - %d ms',
			"\n", $stopEvent->getMemory() / 1024 / 1024, $stopEvent->getDuration()
		));
	}

	/**
	 * {@inheritdoc}
	 */
	public function name(): string {
		return 'calc';
	}

	/**
	 * Allow for different ways to "feed" the input build to the application:
	 *  1. input file
	 *  2. piped content to stdin
	 *  3. input argument.
	 */
	private function getBuildOrderFromInput(): string {
		if (($infile = $this->input->getArg('in_file')) !== null) {
			if (!file_exists($infile) || !is_readable($infile)) {
				throw new RuntimeException("Could not find / read input file '{$infile}'");
			}

			$this->output->writeOutLn("Processing build order from input file {$infile}");

			return file_get_contents($infile);
		}

		if ($this->input->hasPipedContent()) {
			$this->output->writeOutLn('Processing build order from content piped to the script');

			return $this->input->getPipedContent();
		}

		if (($instring = $this->input->getArg('in_string')) !== null) {
			$this->output->writeOutLn('Processing build order from input flag --instring');

			return $instring;
		}

		throw new InvalidUsageException('Must supply input build order in some way and format');
	}

	/**
	 * Print the result of an sc2calc build calculation.
	 * @param Sc2Build $build The build to be printed
	 */
	private function printBuild(Sc2Build $build): void {
		$endTimeString = Utils::simple_time($build->endTime);
		$this->output->writeOutLn(sprintf(
			'%sCalculated build order (%s) with %d events going until %s',
			"\n", $build->race->getValue(), count($build->timeline->_events), $endTimeString
		), Color::BOLD.Color::CYAN);

		$this->output->writeOutLn("\nUsage of production queues", Color::BOLD_WHITE);
		$this->output->writeOutLn(<<<'TEXT'
			This table shows the busy time of your production queues. Production queues which remain completely unused are not shown.
			A production queue is considered destroyed when the structure is morphed into another structure, such as a Warpgate or Orbital Command.
			TEXT);
		$this->output->writeOutLn($build->timeline->queues->__toString());

		$this->output->writeOutLn('Income', Color::BOLD_WHITE);
		$this->output->writeOutLn(<<<TEXT
			This table shows the income generated by your workers. The timeline is divided into timeslots, each corresponding with a different distribution of workers.
			A new timeslot starts when a worker is created, assigned to a job, or transferred to a new base or geyser.
			You have mined a total of {$build->timeline->income->totalMineral($build->endTime)} minerals and {$build->timeline->income->totalGas($build->endTime)} gas at {$endTimeString}.
			TEXT);
		$this->output->writeOutLn($build->timeline->income->__toString());

		if ($build->race->equals(Race::ZERG())) {
			$this->output->writeOutLn('Larvae generated', Color::BOLD_WHITE);
			$this->output->writeOutLn('This table shows the larvae generated by your hatcheries.');
			$this->output->writeOutLn($build->timeline->hatcheries->__toString());
		}
	}
}
